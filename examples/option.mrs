enum Option<T> {
    None,
    Some { item: T },
}

impl<T> Option<T> {
    fn unwrap_or(self, default: T) -> T {
        match self {
            Option::Some { item: item } => item,
            Option::None => default,
        }
    }

    fn map<F, U>(self, f: F) -> Option<U>
        where F: Fn(T) -> U
    {
        match self {
            Option::Some { item: item } => Option::Some { item: f(item) },
            Option::None => Option::None {},
        }
    }

    fn update<F>(&self, f: F)
        where F: Fn(&T)
    {
        match self {
            Option::Some { item: item } => f(item),
            Option::None => {}
        }
    }

    fn as_ref(&self) -> Option<&T> {
        match self {
            Option::Some { item: item } => Option::Some { item: item },
            Option::None => Option::None {},
        }
    }

    fn is_some(&self) -> bool {
        match self {
            Option::Some { item: item } => true,
            Option::None => false,
        }
    }

    fn into_iter(self) -> OptionIter<T> {
        OptionIter { item: self }
    }
}

struct OptionIter<T> {
    item: Option<T>
}

impl<T> Iterator for OptionIter<T> {
    type Item = T;

    fn next(&self) -> Option<T> {
        let item = self.item;
        self.item = Option::None {};
        item
    }
}
