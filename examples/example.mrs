fn main() -> i32 {
    print::<i32>(5);
    print::<bool>(false);
    3
}

fn apply<A, B>(f: fn(A) -> B, x: A) -> B {
    f(x)
}

fn double(x: i32) -> i32 {
    x * 2
}

fn malloc(size: i32) -> *c_void;
fn free(alloc: *c_void);

fn printf(format: *c_char, ...) -> i32;
fn scanf(format: *c_char, ...) -> i32;

fn new<T>() -> *T {
    malloc(size_of::<T>()) as *T
}
fn delete<T>(ref: &T) {
    free(ref as *T as *c_void)
}

fn fac(n: i32) -> i32 {
    let result: i32 = 1;
    loop {
        if n == 0 {
            return result;
        }
        result = result * n;
        n = n - 1
    }
    result
}

struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn is_origin(self) -> bool {
        self.x == 0 & self.y == 0
    }
}

enum Option<T> {
    None,
    Some { item: T },
}

impl<T> Option<T> {
    fn unwrap_or(self, default: T) -> T {
        match self {
            Some { item: item } => item,
            None {} => default,
        }
    }

    fn map<U>(self, f: fn(T) -> U) -> Option<U> {
        match self {
            Some { item: item } => Some::<U> { item: f(item) },
            None {} => None::<U> {},
        }
    }
}

struct Pair<A, B> {
    first: A,
    second: B,
}

trait Sink {
    fn send<T>(self, message: T) -> ();
}

impl<T> Sink for T {
    fn send<S>(self, message: S) {
        let size_S = size_of::<S>();
        let size_T = size_of::<T>();
        printf("Sink of size %d received message of size %d\n", size_T, size_S);
    }
}

trait ToString {
    fn to_string(self) -> *c_char;
}

fn print<T>(x: T) 
    where T: ToString
{
    printf("Printing object: %s\n", x.to_string());
}

impl ToString for i32 {
    fn to_string(self) -> *c_char {
        "i32"
    }
}

impl ToString for bool {
    fn to_string(self) -> *c_char {
        if self {
            "true"
        } else {
            "false"
        }
    }
}
