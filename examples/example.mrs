fn main() -> i32 {
    let opt = Some { item: 5 };
    opt.update(|x| *x = *x * 2);
    opt.unwrap_or(0)
}

fn malloc(size: i32) -> *c_void;
fn free(alloc: *c_void);

fn printf(format: *c_char, ...) -> i32;
fn scanf(format: *c_char, ...) -> i32;

fn new<T>() -> *T {
    malloc(size_of::<T>()) as *T
}
fn delete<T>(ref: *T) {
    free(ref as *c_void)
}

fn apply<F, A, B>(f: F, a: A) -> B
    where F: Fn(A) -> B
{
    f(a)
}

fn double(x: i32) -> i32 {
    x * 2
}

fn fac(n: i32) -> i32 {
    let result: i32 = 1;
    loop {
        if n == 0 {
            return result;
        }
        result = result * n;
        n = n - 1
    }
    result
}

struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn is_origin(&self) -> bool {
        (*self).x == 0 & (*self).y == 0
    }

    fn new(x: i32, y: i32) -> Self {
        let p: Self = Point { x: x, y: y };
        p
    }
}

trait ToString {
    fn to_string(self) -> *c_char;
}

fn print<T>(x: T) 
    where T: ToString
{
    printf("Printing object: %s\n", x.to_string());
}

impl ToString for i32 {
    fn to_string(self) -> *c_char {
        "i32"
    }
}

impl ToString for bool {
    fn to_string(self) -> *c_char {
        if self { "true" } else { "false" }
    }
}

impl ToString for *c_char {
    fn to_string(self) -> *c_char {
        self
    }
}

impl bool {
    fn then_some<T>(self, item: T) -> Option<T> {
        if self {
            Some { item: item }
        } else {
            None {}
        }
    }
}

trait Eq {
    fn eq(&self, other: &Self) -> bool;
}

impl Eq for i32 {
    fn eq(&self, other: &Self) -> bool {
        *self == *other
    }
}

impl Eq for bool {
    fn eq(&self, other: &bool) -> bool {
        *self == *other
    }
}
