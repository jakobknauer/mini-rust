fn main() -> i32 {
    let points: *Point = alloc_n(10);

    let n = 0;
    loop {
        if n == 10 {
            break;
        }

        points.offset(n).x = n;
        points.offset(n).y = n;
        n = n + 1;
    }

    let n = 0;
    let result = 0;
    loop {
        if n == 10 {
            break;
        }

        result = result + points.offset(n).x * points.offset(n).y;
        n = n + 1;
    }

    printf("result = %d\n", result);

    delete(points);

    0
}

fn malloc(size: i32) -> *c_void;
fn free(alloc: *c_void);

fn printf(format: *c_char, ...) -> i32;
fn scanf(format: *c_char, ...) -> i32;

fn alloc<T>() -> *T {
    malloc(size_of::<T>()) as *T
}
fn alloc_n<T>(n: i32) -> *T {
    malloc(n * size_of::<T>()) as *T
}
fn delete<T>(ref: *T) {
    free(ref as *c_void)
}

fn apply<F, A, B>(f: F, a: A) -> B
    where F: Fn(A) -> B
{
    f(a)
}

fn double(x: i32) -> i32 {
    x * 2
}

fn fac(n: i32) -> i32 {
    let result: i32 = 1;
    loop {
        if n == 0 {
            return result;
        }
        result = result * n;
        n = n - 1
    }
    result
}

struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn is_origin(&self) -> bool {
        self.x == 0 && self.y == 0
    }

    fn new(x: i32, y: i32) -> Self {
        let p: Self = Point { x: x, y: y };
        p
    }
}

trait ToString {
    fn to_string(self) -> *c_char;
}

fn print<T>(x: T) 
    where T: ToString
{
    printf("Printing object: %s\n", x.to_string());
}

impl ToString for bool {
    fn to_string(self) -> *c_char {
        if self { "true" } else { "false" }
    }
}

impl ToString for *c_char {
    fn to_string(self) -> *c_char {
        self
    }
}

impl bool {
    fn then_some<T>(self, item: T) -> Option<T> {
        if self {
            Some { item: item }
        } else {
            None {}
        }
    }
}

trait Eq {
    fn eq(&self, other: &Self) -> bool;
}

impl Eq for i32 {
    fn eq(&self, other: &Self) -> bool {
        *self == *other
    }
}

impl Eq for bool {
    fn eq(&self, other: &bool) -> bool {
        *self == *other
    }
}

fn convert<A, B>(x: A) -> B
    where A: Into<B>
{
    x.into()
}

trait Into<T> {
    fn into(self) -> T;
}

impl<S> Into<S> for S {
    fn into(self) -> S {
        self
    }
}

impl Into<bool> for i32 {
    fn into(self) -> bool {
        self != 0
    }
}

impl Into<i32> for bool {
    fn into(self) -> i32 {
        if self { 1 } else { 0 }
    }
}
