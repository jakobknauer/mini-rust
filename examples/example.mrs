fn main() -> i32 {
    let f = select::<fn(i32) -> i32>(true, fac, identity::<i32>);
    let b = concat::<i32, Point, bool>(diag_point, is_origin, f(3));
    noop::<&i32>();
    if b { 1 } else { 2 }
}

fn noop<T>() {}

fn fac(n: i32) -> i32 {
    let result: i32 = 1;
    loop {
        if n == 0 {
            return result;
        }
        result = result * n;
        n = n - 1
    }
    result
}

struct Point {
    x: i32,
    y: i32,
}

fn scalar_product(p: Point, q: Point) -> i32 {
    p.x * q.x + p.y * q.y
}

fn is_origin(p: Point) -> bool {
    p.x == 0 & p.y == 0
}

fn diag_point(c: i32) -> Point {
    Point { x: c, y: c }
}

enum Expr {
    Constant { c: i32 },
    Add { left: i32, right: i32 },
    Mul { left: i32, right: i32 },
}

fn eval(expr: Expr) -> i32 {
    match expr {
        Constant { c: c } => c,
        Add { left: left, right: right } => left + right,
        Mul { left: a, right: b } => a * b,
    }
}

fn identity<T>(x: T) -> T { 
    x 
}

fn invoke<A, B>(f: fn(A) -> B, x: A) -> B {
    f(x)
}

fn select<T>(switch: bool, a: T, b: T) -> T {
    if switch { a } else { b }
}

fn concat<A, B, C>(f: fn(A) -> B, g: fn(B) -> C, a: A) -> C {
    g(f(a))
}
