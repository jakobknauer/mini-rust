fn main() -> i32 {
    let x = 1.pair_with::<bool>(false);

    let opt = None::<i32> {};
    let opt = opt.map::<i32>(double);

    opt.unwrap_or(10)
}

fn double(x: i32) -> i32 {
    x * 2
}

fn malloc(size: i32) -> *c_void;
fn free(alloc: *c_void);

fn printf(format: *c_char, ...) -> i32;
fn scanf(format: *c_char, ...) -> i32;

fn new<T>() -> *T {
    malloc(size_of::<T>()) as *T
}
fn delete<T>(ref: &T) {
    free(ref as *T as *c_void)
}

fn fac(n: i32) -> i32 {
    let result: i32 = 1;
    loop {
        if n == 0 {
            return result;
        }
        result = result * n;
        n = n - 1
    }
    result
}

struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn is_origin(self) -> bool {
        self.x == 0 & self.y == 0
    }
}

enum Option<T> {
    None,
    Some { item: T },
}

impl<T> Option<T> {
    fn unwrap_or(self, default: T) -> T {
        match self {
            Some { item: item } => item,
            None {} => default,
        }
    }

    fn map<U>(self, f: fn(T) -> U) -> Option<U> {
        match self {
            Some { item: item } => Some::<U> { item: f(item) },
            None {} => None::<U> {},
        }
    }
}

struct Pair<A, B> {
    first: A,
    second: B,
}

impl<T> T {
    fn pair_with<S>(self, other: S) -> Pair<T, S> {
        Pair::<T, S> { first: self, second: other }
    }
}

trait Blah {
    fn foo(self) -> bool;
}
