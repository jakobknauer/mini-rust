fn main() -> i32 {
    0
}

fn apply<A, B, F>(f: F, a: A) -> B
    where F: Fn(A) -> B
{
    f(a)
}

fn malloc(size: i32) -> *c_void;
fn free(alloc: *c_void);

fn printf(format: *c_char, ...) -> i32;
fn scanf(format: *c_char, ...) -> i32;

fn alloc<T>() -> *T {
    malloc(size_of::<T>()) as *T
}
fn alloc_n<T>(n: i32) -> *T {
    malloc(n * size_of::<T>()) as *T
}
fn delete<T>(ref: *T) {
    free(ref as *c_void)
}

fn double(x: i32) -> i32 {
    x * 2
}

fn fac(n: i32) -> i32 {
    let result: i32 = 1;
    while n > 0 {
        result = result * n;
        n = n - 1
    }
    result
}

struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn is_origin(&self) -> bool {
        self.x == 0 && self.y == 0
    }

    fn new(x: i32, y: i32) -> Self {
        let p: Self = Point { x: x, y: y };
        p
    }
}

trait ToString {
    fn to_string(self) -> *c_char;
}

fn print<T>(x: T) 
    where T: ToString
{
    printf("Printing object: %s\n", x.to_string());
}

impl ToString for bool {
    fn to_string(self) -> *c_char {
        if self { "true" } else { "false" }
    }
}

impl ToString for *c_char {
    fn to_string(self) -> *c_char {
        self
    }
}

impl bool {
    fn then_some<T>(self, item: T) -> Option<T> {
        if self {
            Option::Some { item: item }
        } else {
            Option::None {}
        }
    }
}

trait Eq {
    fn eq(&self, other: &Self) -> bool;
}

impl Eq for i32 {
    fn eq(&self, other: &Self) -> bool {
        *self == *other
    }
}

impl Eq for bool {
    fn eq(&self, other: &bool) -> bool {
        *self == *other
    }
}

fn convert<A, B>(x: A) -> B
    where A: Into<B>
{
    x.into()
}

trait Into<T> {
    fn into(self) -> T;
}

impl<S> Into<S> for S {
    fn into(self) -> S {
        self
    }
}

impl Into<bool> for i32 {
    fn into(self) -> bool {
        self != 0
    }
}

impl Into<i32> for bool {
    fn into(self) -> i32 {
        if self { 1 } else { 0 }
    }
}

// trait Iterator {
//     type Item;
//     fn next(&self) -> Option<Self::Item>;
// }
