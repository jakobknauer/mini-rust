fn main() -> i32 {
    let opt = Some::<*c_char> { item: "hello" };
    printf("%s\n", opt.unwrap_or("bye"));

    let opt = Some::<i32> { item: 5 };
    opt.unwrap_or(1)
}

fn malloc(size: i32) -> *c_void;
fn free(alloc: *c_void);

fn printf(format: *c_char, ...) -> i32;
fn scanf(format: *c_char, ...) -> i32;

fn new<T>() -> *T {
    malloc(size_of::<T>()) as *T
}
fn delete<T>(ref: &T) {
    free(ref as *T as *c_void)
}

fn fac(n: i32) -> i32 {
    let result: i32 = 1;
    loop {
        if n == 0 {
            return result;
        }
        result = result * n;
        n = n - 1
    }
    result
}

struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn is_origin(self) -> bool {
        self.x == 0 & self.y == 0
    }
}

enum Option<T> {
    None,
    Some { item: T },
}

impl<T> Option<T> {
    fn unwrap_or(self, default: T) -> T {
        match self {
            Some { item: item } => item,
            None {} => default,
        }
    }
}
