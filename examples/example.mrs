fn main() -> i32 {
    let point = (1, 2);
    let r_point = &point;
    let rr_point = &r_point;
    let rrr_point = &rr_point;
    
    printf("%d\n", point.1);
    printf("%d\n", r_point.1);
    printf("%d\n", rr_point.1);
    printf("%d\n", rrr_point.1);

    0
}

fn false_() -> bool {
    printf("\tfalse_()\n");
    false
}

fn true_() -> bool {
    printf("\ttrue_()\n");
    true
}

fn malloc(size: i32) -> *c_void;
fn free(alloc: *c_void);

fn printf(format: *c_char, ...) -> i32;
fn scanf(format: *c_char, ...) -> i32;

fn new<T>() -> *T {
    malloc(size_of::<T>()) as *T
}
fn delete<T>(ref: *T) {
    free(ref as *c_void)
}

fn apply<F, A, B>(f: F, a: A) -> B
    where F: Fn(A) -> B
{
    f(a)
}

fn double(x: i32) -> i32 {
    x * 2
}

fn fac(n: i32) -> i32 {
    let result: i32 = 1;
    loop {
        if n == 0 {
            return result;
        }
        result = result * n;
        n = n - 1
    }
    result
}

struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn is_origin(&self) -> bool {
        (*self).x == 0 & (*self).y == 0
    }

    fn new(x: i32, y: i32) -> Self {
        let p: Self = Point { x: x, y: y };
        p
    }
}

trait ToString {
    fn to_string(self) -> *c_char;
}

fn print<T>(x: T) 
    where T: ToString
{
    printf("Printing object: %s\n", x.to_string());
}

impl ToString for bool {
    fn to_string(self) -> *c_char {
        if self { "true" } else { "false" }
    }
}

impl ToString for *c_char {
    fn to_string(self) -> *c_char {
        self
    }
}

impl bool {
    fn then_some<T>(self, item: T) -> Option<T> {
        if self {
            Some { item: item }
        } else {
            None {}
        }
    }
}

trait Eq {
    fn eq(&self, other: &Self) -> bool;
}

impl Eq for i32 {
    fn eq(&self, other: &Self) -> bool {
        *self == *other
    }
}

impl Eq for bool {
    fn eq(&self, other: &bool) -> bool {
        *self == *other
    }
}

fn convert<A, B>(x: A) -> B
    where A: Into<B>
{
    x.into()
}

trait Into<T> {
    fn into(self) -> T;
}

impl<S> Into<S> for S {
    fn into(self) -> S {
        self
    }
}

impl Into<bool> for i32 {
    fn into(self) -> bool {
        self != 0
    }
}

impl Into<i32> for bool {
    fn into(self) -> i32 {
        if self { 1 } else { 0 }
    }
}
